# 데이터 타입.
# 1. Data Type의 종류
데이터 타입은 `primitive type`, `Reference type` 크게 2가지고 나뉨.

이때 구분은 아래처럼 된다.

```text
data type  +-> primitive type -> Number, String, Boolean, null, undefined, Symbol
           | 
           |
           +-> Reference type -> Object - Array,Function, Date. RegExp, Map, Set
```
일반적으로 두 type의 차이점이 아래처럼 알고 있다.
Primitive : 불변성 Data이기 때문에 값 자체가 변하지 않는다.
Reference : 참조형 Data이기 때문에 메모리의 주솟값을 복사한다.

하지만 실제 내부적으로는 그렇게 되지 않는데....

# 2. Data Type에 대한 배경지식
아래 코드를 보면
```javascript
var a = 20
```
단순하게 변수 a는 20이라는 값을 가리킨다고 설명하나

사실은
1. 변수를 만든다.
2. 그 변수를 식별하기 위한 이름은 'a'이다.
3. a가 가리키는 Data는 20이다

의 순서로 동작합니다.

때문에 내부적으로는 메모리에 `식별자 정보`, `식별자가 가리키는 데이터` 가 따로 저장됩니다.

# 3. 변수 선언과 데이터 할당
위에서 알아보았듯, 변수를 만들 때는 Data를 가리키는 식별자정보, 그리고 Data의 정보가 담기게 됩니다.

이때 이 구조를 컴퓨터의 메모리 구조로보면 아래처럼 볼 수 있습니다.

식별자 영역
|주소  |...|1002|1003                   |1004|1005|...|
|---|---|---|---|---|---|---|
|데이터|   |    |식별자명 : a, 값 : @5003|    |    |   |

데이터 영역
|주소  |...|5002|5003                   |5004|5005|...|
|---|---|---|---|---|---|---|
|데이터|   |    |20                     |    |    |   |

임의로 식별자 영역, 데이터 영역이라고 기술 하였지만

여턴 식별자 정보를 저장하는 영역해 해당 식별자의 이름과 가리키는 위치값을 저장하고

해당 위치값에 실제 데이터를 저장하게 됩니다.

그래서 여기서 알 수 있는것은 primitive type역시 주소값을 저장한다는 점 입니다!
(이런 식으로 동작하는 이유는 식별자는 문자이기 때문에 길이의 제한이 없다는 점 때문 + 효율성 때문 입니다.)

이때 식별자 a가 가리키는 변수값이 바뀔 경우, 아래처럼 변경이 발생 합니다.

```javascript
var a = 20
a = 50
```
식별자 영역
|주소  |...|1002|1003                   |1004|1005|...|
|---|---|---|---|---|---|---|
|데이터|   |    |식별자명 : a, 값 : @5004|    |    |   |

데이터 영역
|주소  |...|5002|5003                   |5004|5005|...|
|---|---|---|---|---|---|---|
|데이터|   |    |~~20~~                 |50  |    |   |

저 그럼 이 내용은 불변값으로 확장시켜 볼까요?

# 4. 기본형 데이터와 참조형 데이터
variable과 constant의 경우 단어에서 알 수 있듯 `변할 수 있음 vs 변할 수 없음`의 특징을 가지고 있습니다.

ES6이후에 데이터의 불변성 이라는 내용을 많이 다루게 됩니다.

이때 데이터의 불변성과 variable, constant를 구분해서 이해할 필요성이 있습니다.

variable과 constant : 식별자가 가리키는 값이 변경될 수 있냐 or 없냐 구분 ==> 식별자 영역이 수정될 수 있냐의 여부

데이터의 불변성 : 데이터 영역의 값이 변할 수 없다는 것을 의미 ==> 데이터 영역에 한번 쓰여진 값을 사라질때까지 변하지 않음

3장에서 다뤘던 코드를 예시로 보겠습니다.
```javascript
var a = 20
a = 50
```
위 코드를 보면, a = 20으로 만들어 진 이후 a = 50으로 값이 변합니다.

식별자 a가 가리키는 값이 `@5004`메모리 주소로 바뀌었으므로 a는 변수입니다.

이때 기존에 `@5003`위치에 있던 20이라는 값은 변하지 않았고 `@5004`위치에 새로운 값이 만들어 졌습니다.

그렇기 때문에 `식별자 a는 변수이고 a가 가리키는 data를 불변값` 입니다.

Primitive type의 data들은 데이터 영역에 Data가 바로 기록되기 때문에 불변값이 됩니다.

## 4_1. 가변값(mutable)
이때 Reference type의 data같은 경우는 조금 다르게 동작하게 됩니다.

아래 코드르 보실까요?
```javascript
var a = {b : 20, c : 50}
a.b = 220
```
식별자 영역
|주소  |...|1002|1003                   |1004|1005|...|
|---|---|---|---|---|---|---|
|데이터|   |    |식별자명 : a, 값 : @5003|    |    |   |

데이터 영역
|주소  |...|5002|5003                   |5004|5005|5006|
|---|---|---|---|---|---|---|
|데이터|   |    |@7001 ~ ?              |20  |50  |    |

a's object의 영역
|주소  |...|7002|7003                   |7004                   |7005|...|
|---|---|---|---|---|---|---|
|데이터|   |    |식별자명 : b, 값 : @5004|식별자명 : c, 값 : @5005|    |   |

mutable의 경우 위처럼 식별자가 처음 가리키는 Data영역 위치에 Data가 있는 것이 아니라, object의 위치를 가리키게 됩니다.

그리고 그 object가 다시 Data영역을 가리키게 됩니다.

그래서 이때 a.b의 값을 변경하면 아래처럼 바뀌게 됩니다.

식별자 영역
|주소  |...|1002|1003                   |1004|1005|...|
|---|---|---|---|---|---|---|
|데이터|   |    |식별자명 : a, 값 : @5003|    |    |   |

데이터 영역
|주소  |...|5002|5003                   |5004|5005  |5006|
|---|---|---|---|---|---|---|
|데이터|   |    |@7001 ~ ?              |20  |~~50~~|220 |

a's object의 영역
|주소  |...|7002|7003                   |7004                   |7005|...|
|---|---|---|---|---|---|---|
|데이터|   |    |식별자명 : b, 값 : @5004|식별자명 : c, 값 : @5005|    |   |

이제 mutable과 immutable의 차이점이 보이시나요?

## 4_2. 변수의 복사
위를 통해서 mutable과 immutable의 차이점을 볼 수 있었을 겁니다.

이제 변수의 복사를 할 때 얕은복사와 깊은복사를 이해할 수 있습니다.

내용을 정리하기 전에 얕을복사와 깊은복사를 비교해보면

얕은복사 : 단순하게 식별자가 가리키는 값을 다른 식별자에 복사해 주는것을 의미.
(a와 copy_a가 종속적임)

깊은복사 : 식별자가 가리키는 값이 주소값일 경우, 재귀적으로 데이터가 존재하는 위치까지 가서 데이터를 복사해옴
(a와 copy_a가 완전 독립되어있음)

### 4_2_1. immutable의 변수 복사
먼저 immutable일 경우를 보겠습니다.
```javascript
var a = 20
copy_a = a
```
식별자 영역
|주소  |...|1002|1003                   |1004                        |1005|...|
|---|---|---|---|---|---|---|
|데이터|   |    |식별자명 : a, 값 : @5003|식별자명 : copy_a, 값 : @5003|    |   |

데이터 영역
|주소  |...|5002|5003               |5004|5005|...|
|---|---|---|---|---|---|---|
|데이터|   |    |20                 |    |    |   |

불변형은 식별자의 값 이 가리키는부분에 바로 Data가 있습니다.

때문에 얕은복사나 깊은복사나 차이점이 없습니다.

이때 `copy_a = 30`을 실행하면 아래처럼 작동하게 되겠죠
식별자 영역
|주소  |...|1002|1003                   |1004                        |1005|...|
|---|---|---|---|---|---|---|
|데이터|   |    |식별자명 : a, 값 : @5003|식별자명 : copy_a, 값 : @5004|    |   |

데이터 영역
|주소  |...|5002|5003               |5004|5005|...|
|---|---|---|---|---|---|---|
|데이터|   |    |20                 |30|    |   |

`@5003`위치의 값이 바뀌는 것이 아니라, 다른 위치에 Data를 만들고, 이 메모리주소를 copy_a가 가지고오게 됩니다.

### 4_2_2. mutable의 변수 복사
반면 mutable의 경우를 볼까요?
```javascript
var a = {b : 20, c : 50}
var copy_a = a
```
식별자 영역
|주소  |...|1002|1003                   |1004                        |1005|...|
|---|---|---|---|---|---|---|
|데이터|   |    |식별자명 : a, 값 : @5003|식별자명 : copy_a, 값 : @5003|    |   |

데이터 영역
|주소  |...|5002|5003                   |5004|5005  |5006|
|---|---|---|---|---|---|---|
|데이터|   |    |@7001 ~ ?              |20  |50    |    |

a's object의 영역
|주소  |...|7002|7003                   |7004                   |7005|...|
|---|---|---|---|---|---|---|
|데이터|   |    |식별자명 : b, 값 : @5004|식별자명 : c, 값 : @5005|    |   |

이 상태에서 object의 값에 접근하는 순서를 보면

`a.b: @5003 -> @7003 -> @5004 -> 20`
`a_copy.b: @5003 -> @7003 -> @5004 -> 20`

때문에, a.b의 값을 바꿀 경우 a_copy.b의 값 역시 바뀌게 됩니다.
(`@7003`위치가 가리키는 값이 바뀌기 때문에)

```javascript
a.b = 220
//==copy_a.b = 220
```
식별자 영역
|주소  |...|1002|1003                   |1004                        |1005|...|
|---|---|---|---|---|---|---|
|데이터|   |    |식별자명 : a, 값 : @5003|식별자명 : copy_a, 값 : @5003|    |   |

데이터 영역
|주소  |...|5002|5003                   |5004  |5005  |5006|
|---|---|---|---|---|---|---|
|데이터|   |    |@7001 ~ ?              |~~20~~|50    |220  |

a's object의 영역
|주소  |...|7002|7003                   |7004                   |7005|...|
|---|---|---|---|---|---|---|
|데이터|   |    |식별자명 : b, 값 : @5006|식별자명 : c, 값 : @5005|    |   |

때문에 mutable의 경우 변수의 깊은복사와 얕은복사가 달라지게 됩니다.
(깊은복사를 하는 방법은 다음챕터에서 다룹니다.)

# 5. Immutable object
Primitive Type의 object는 기본적으로 Immutable object입니다.

하지만 Reference Type Data역시 Immutable object처럼 복사를 하는것이 가능합니다.

1. immutable.js, immer.js와같은 user-defined package를 사용하거나
2. ES6의 spread연산자를 사용해서 구현할 수 있습니다.

결국 mutable object의 깊은복사는

**mutable object를 복사할 때 Immutable object처럼 a와 copy_a가 독립적인 object를 만드는 것입니다.**

코어자바스크립트 책에서는 재귀함수를 통해서 `Object type`의 깊은복사를 구현하는 방법은 아래와 같습니다.
```javascript
const copy_func = function(target) {
    var result = {}
    if (typeof target === "object" && target !== null){
        for (var prop in target){
            result[prop] = copy_func(target[prop]);
        }
    } else {
        result = target
    } return result
}
```
재귀함수를 통해서 value가 `Object type`일 경우 다시금 반복적으로 copy_func를 수행합니다.

결국 깊은복하는 동일한 Data를 같는 새로운 object를 만들어 내는 작업 입니다.

또는 `Object type`의 경우 Json과 그 구조가 동일하기 때문에 `JSON object`를 사용해서 깊은복사를 할 수 있습니다.
```javascript
const copy_func_json = function(target) {
    return JSON.parse(JSON.stringify(target));
}
```

# 6. null과 undefined
다른 Programming 언어를 사용 하다가 JavaScript에서 사용자를 당황시키는 친구들 입니다.

>null : 값 자체가 없음
>undefined : 정의되어있지 않음

분명 한글로 풀어 써도 큰 차이점이 없습니다.

책에는 긴 설명이 되어있으나, undefined는 JavaScript Engine에서 만들어내는 값으로
1. 값을 대입하지 않은 변수, 즉 데이터 영역의 메로리 주소를 지정하지 않은 식별자에 접근할 때
`var a; console.log(a)`
2. object내부의 좋재하지 않는 property에 접근하려고 할 때
`var a = {b : 20}; console.log(a.c)`
3. return문이 없거나 호출되지 않는 함수의 실행 결과
`var a = () => {b = 20};console.log(a())`

위 3가지 경우 외에는 사용자는 `null`을 사용하는것이 옳은 방법 입니다.

위처럼 깔끔하게 정리되면 좋겠지만

문제는 이 외에 아래처럼 Array를 생성했을때 마주하게 됩니다.
```javascript
var a = Array(3)
console.log(a)
//>>[empty * 3]
```
위 코드의 경우 크기가 3인 Array를 만듭니다.

문제는 이 Array의 3개의 공간에는 `undefined`가 할당되는것이 아니라 아예 비어있는 상태, `empty` 입니다.

반복문을 동작할 때 undefined와 empty는 다른 동작을 보여줍니다.

그래서 JavaScript를 사용할 경우, 내가 사용할 Array object가 undefined상태인지, empty상태인지를 꼭 확인해야 합니다.

