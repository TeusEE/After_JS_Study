# 데이터 타입

- 데이터 타입의 종류
- 데이터 타입에 관한 배경지식
  - 메모리와 데이터
  - 식별자와 변수
- 변수 선언과 데이터 할당
  - 변수 선언
  - 데이터 할당
- 기본형 데이터와 참조형 데이터
  - 불변값
  - 가변값
  - 변수 복사 비교
- 불변 객체(immutable object)
  - 불변 객체를 만드는 간단한 방법
  - 얕은 복사와 깊은 복사
- undefined와 null

## 데이터 타입의 종류

자바스크립트의 데이터 타입에는 크게 기본형(원시형, primitive type)과 참조형(reference type) 두가지가 있다.

- 기본형 : 숫자(number), 문자열(string), 불리언(boolean), null, undefined, 심볼(Symbol)
- 참조형 : 객체(object), 배열(Array), 함수(Function), 날짜(Date), 정규표현식(RegExp), Map, WeakMap, Set, WeakSet 등

기본형과 참조형을 구분하는 기준은 일반적인 기본형은 할당이나 연산 시 **_복제_**, 참조형은 **_참조_**된다.

## 데이터 타입에 관한 배경지식

### 메모리와 데이터

- 비트(bit): 0 또는 1만 표현할 수 있는 하나의 메모리 조각
- 바이트(byte): 비트의 묶음 단위

### 식별자와 변수

변수(variable)와 식별자(identifier)를 혼용하는 경우가 많다.

- 변수: 변할 수 있는 수
  영어 단어 variable은 원래 '변할 수 있다'라는 형용사이지만 컴퓨터 용어로 쓸 때는 '변할 수 있는 무언가'라는 명사로 확장시켰다.

  > 여기서 '무언가'란 **데이터**를 말한다. 숫자, 문자열, 객체, 배열

- 식별자: 어떤 데이터를 식별하는 데 사용하는 이름. 즉, **변수명**

## 변수 선언과 데이터 할당

### 변수 선언

```javascript
var a;
```

위 예제를 말로 풀어 쓰면 **_변할 수 있는 데이터를 만든다. 이 데이터의 식별자는 a로 한다_** 가 된다.  
변할 수 있는 데이터이니 선언할 때는 undefined이더라도 나중에 다른 값으로 바꾸면 된다.

결국 변수란, **_변경 가능한 데이터가 담길 수 있는 공간 또는 그릇_**이라고 생각하면 된다.

이를 바탕으로 컴퓨터 메모리 구조를 표현하면 아래와 같다.

|  주소  | ... | 1002 | 1003            | 1004 | 1005 | ... |
| :----: | :-: | :--: | :-------------- | :--: | :--: | :-: |
| 데이터 |     |      | 이름: a<br> 값: |      |      |

컴퓨터가 명령을 받으면 메모리에서 비어있는 공간을 확보 한 후, 그 공간의 이름(식별자)를 지정한다.  
이것이 변수 선언의 과정이다.

위 예제에서는 식별자를 a로 지정하였고, 사용자가 a에 접근하고자 하면 컴퓨터는 메모리에서 a라는 이름을 가진 주소를 검색해 해당 공간에 담긴 데이터를 반환할 것이다.

### 데이터 할당

```javascript
var a; // 변수 a 선언
a = "abc"; // 변수 a에 데이터 할당

var a = "abc"; // 변수 선언과 할당을 한 문장으로 표현
```

데이터 선언 과정을 거친 후, a라는 이름을 가진 주소를 검색해서 그곳에 문자열 'abc'를 할당한다.  
이것이 데이터 할당 과정이다.

실제로는 해당 위치에 문자열 'abc'를 직접 저장 X

- **데이터 영역** : 데이터를 저장하기 위한 메모리 공간
- **변수 영역** : 식별자를 지정하고 실제 데이터의 주소를 저장하는 메모리

> 🤔 이렇게 메모리 공간을 나누는 이유는?  
> **\*데이터 변환의 자유** + **메모리를 더욱 효율적으로 관리\*** 하기 위한 고민의 결과이다.  
> 자바스크립트는 숫자형 데이터 64비트(8바이트)를 확보하지만, 문자열은 한 글자당 영어 1바이트, 한글 2바이트로 특별한 규격없이 전체 글자 수가 가변적으로 메모리 용량도 가변적이다.
>
> 메모리 공간을 나누지 않고 변수 영역에 바로 실제 데이터를 저장한다면, 데이터 변환 시 '확보된 공간을 변한된 데이터 크기에 맞게 늘리는 작업'이 필요하다. 해당 공간이 메모리 상의 마지막이라면 뒤쪽으로 늘리기만 하면 된다. 하지만 중간이라면 데이터를 옮기고, 식별자의 크기를 늘리는 작업으로 컴퓨터가 처리해야 할 연산이 많아진다.
> 그래서 문자열 데이터의 변환을 처리하기 위해 변수와 데이터를 별도의 공간에 나누어 저장하는 것이 효율적이다.

**_변수 영역_**
| 주소 | ... | 1002 | 1003 | 1004 | 1005 | ... |
| :--: | :--: | :--: | :-- | :--: | :--: | :--: |
| 데이터 | | | 이름: a<br>값: @5004 | | |

**_데이터 영역_**  
| 주소 | ... | 5002 | 5003 | 5004 | 5005 | ... |
| :--: | :--: | :--: | :--: | :-- | :--: | :--: |
| 데이터 | | | | 'abc' | |

<span style="font-size:150%">**데이터 변환**</span>

```javascript
a = "abcdef";
```

**_변수 영역_**
| 주소 | ... | 1002 | 1003 | 1004 | 1005 | ... |
| :--: | :--: | :--: | :-- | :--: | :--: | :--: |
| 데이터 | | | 이름: a<br>값: @5005 | | |

**_데이터 영역_**  
| 주소 | ... | 5002 | 5003 | 5004 | 5005 | ... |
| :--: | :--: | :--: | :--: | :-- | :-- | :--: |
| 데이터 | | | | 'abc' | 'abcdef' |

> 기존(@5004) 데이터는 자신이 주소를 저장하는 변수가 하나도 없게 되면 가비지 컬렉터(garbage collector)의 수거 대상이 된다.

## 기본형 데이터와 참조형 데이터

### 불변값

변수(variable)와 상수(constant)를 구분하느 성질은 **_'변경 가능성'_** 이다.

이 때, 불변값과 상수를 같은 개념으로 오해하기 쉽다.

- 변수와 상수를 구분 짓는 변경 가능성의 대상 => **_변수 영역 메모리_**  
  한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당할 수 있는지의 여부가 중요

- 불변성 여부를 구분할 때의 변경 가능성의 대상 => **_데이터 영역 메모리_**

기본형 데이터인 숫자, 문자열, boolean, null, undefined, Symbol은 모두 **불변값**이다.

```javascript
var a = "abc";
a = a + "def";

var b = 5;
var c = 5;
b = 7;
```

아까 데이터 선언과 할당에서 메모리 구조로 표현한 것을 떠올려 본다면,  
변수 a, b, c 모두 데이터 영역에서 이미 저장된 데이터를 변환하는 것이 아닌 **_별도의 공간에 새로운 데이터를 저장한다_** 고 할 수 있다.

이처럼 변경은 실제로 값을 바꾸는 것이 아닌, 새로 만드는 동작을 통해 이루어진다.  
이것이 바로 **_불변값의 성질_**이다.  
한 번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않는다.

### 가변값

참조형 데이터의 기본적인 성질은 **가변값**이다.  
하지만 설정에 따라 변경 불가능한 경우도 있고, 아예 불변값으로 활용하는 방안도 있다.

> 설정에 따라 불가능한 경우 : Object.defineProperty, Object.freeze 등

```javascript
var obj1 = {
  x: 3,
  arr: [3, 4, 5], // 중첩 객체(nested object)
};
```

**_변수 영역_**
| 주소 | 1001 | 1002 | 1003 | 1004 | ... |
| :--: | :--: | :-- | :--: | :--: | :--: |
| 데이터 | | 이름: obj1<br>값: @5001 | | | |

**_데이터 영역_**  
| 주소 | 5001 | 5002 | 5003 | 5004 | 5005 | ... |
| :--: | :-- | :-- | :-- | :-- | :-- | :-- |
| 데이터 | @7103 ~ ? | 3 | @8104 ~ ? | 4 | 5 | |

**_객체 @5001의 변수 영역_**  
| 주소 | 7103 | 7104 | ... |
| :--: | :-- | :-- | :--: |
| 데이터 | 이름: x<br>값: @5002 | 이름: arr<br>값: @5003 | |

**_객체 @5003의 변수 영역_**  
| 주소 | 8104 | 8105 | 8106 |
| :--: | :-- | :-- | :-- |
| 데이터 | 이름: 0<br>값: @5002 | 이름: 1<br>값: @5004 | 이름: 2<br>값: @5005 |

기본형 데이터와의 차이는 '**객체의 변수(프로퍼티) 영역**'이 별도로 존재한다는 점이다.  
객체가 별도로 할애한 영역은 변수 영역일 뿐 ‘데이터 영역’은 기존 메모리 공간을 그대로 활용한다. 데이터 영역의 값은 모두 불변값이지만 변수에는 다른 값을 대입할 수 있다. 이 부분 때문에 흔히 참조형 데이터는 불변(immutable)하지 않다(가변값이다)라고 하는 것이다.

```javascript
obj.arr = "str";
```

**_데이터 영역_**  
| 주소 | 5001 | 5002 | 5003 | 5004 | 5005 | 5006 |
| :--: | :-- | :-- | :-- | :-- | :-- | :-- |
| 데이터 | @7103 ~ ? | 3 | @8104 ~ ? | 4 | 5 | 'str' |

**_객체 @5001의 변수 영역_**  
| 주소 | 7103 | 7104 | ... |
| :--: | :-- | :-- | :--: |
| 데이터 | 이름: x<br>값: @5002 | 이름: arr<br>값: @5006 | |

재할당을 하게 되면 데이터 영역에 새 값을 할당하고 객체의 변수 영역에 저장된 주소을 변경한다.  
그리고 주소를 변경함으로서 기존 데이터(@5003과 @8104~@8106)은 더이상 자신의 주소를 참조하는 변수가 하나도 없게 되어 가비지 컬렉터의 수거 대상이된다.

> 어떤 데이터에 대해 자신의 주소를 참조하는 변수의 개수를 **참조 카운트**라고 한다.

### 변수 복사 비교

```javascript
var a = 10;
var b = a;
var obj1 = { c: 10, d: "ddd" };
var obj2 = obj1;

b = 15;
obj2.c = 20;
obj2 = { c: d, f: "ddd" };
```

**_변수 영역_**
| 주소 | 1001 | 1002 | 1003 | 1004 | ... |
| :--: | :-- | :-- | :-- | :-- | :--: |
| 데이터 | 이름: a<br>값: @5001 | 이름: b<br>값: ~~@5001~~ @5004 | 이름: obj1<br>값: @5002 | 이름: obj2<br>값: ~~@5002~~ @5006 | |

**_데이터 영역_**  
| 주소 | 5001 | 5002 | 5003 | 5004 | 5005 | 5006 | ... |
| :--: | :-- | :-- | :-- | :-- | :-- | :-- | :--: |
| 데이터 | 10 | @7103 ~ ? | 'ddd' | 15 | 20 | @8204 ~ ? |

**_객체 @5002의 변수 영역_**
| 주소 | 7103 | 7104 | ... |
| :--: | :-- | :-- | :--: |
| 데이터 | 이름: c<br>값: ~~@5001~~ @5005 | 이름: d<br>값: @5003 |

**_객체 @5006의 변수 영역_**
| 주소 | 8204 | 8205 | ... |
| :--: | :-- | :-- | :--: |
| 데이터 | 이름: c<br>값: @5005 | 이름: d<br>값: @5003 |

대부분의 자바스크립트 책에서 '기본형은 값을 복사하고 참조형은 주솟값을 복사한다'라고 설명한다.  
엄밀히 따지면 자바스크립트의 모든 데이터 타입은 참조형 데이터일 수 밖에 없다. 그래서 변수 복사를 하면 모두 같은 주소를 바라보게 된다. 다만 기본형은 주솟값을 복사하는 과정이 한 번만 이뤄지고, 참조형은 한 단계를 더 거친다는 차이가 있는 것이다.

그래서 `obj2.c = 20`를 하면 obj1와 obj2는 같은 객체 변수 영역을 바라보고 있었고, 그 변수 영역의 내부 프로퍼티인 c의 값을 변경하여 obj1과 obj2를 `===`로 비교하면 같다고 나오는 것이다. 하지만 obj2를 새로운 객체로 변경하면 서로 다른 객체 변수 영역을 바라보기 때문에 값이 다르다고 나오게 된다.

참조형 데이터가 '가변값'이라고 설명할 때의 '가변'은 참조형 데이터 자체를 변경하는 경우가 아니라 그 내부의 프로퍼티를 변경할 때만 성립한다.

## 불변 객체

### 불변 객체를 만드는 간단한 방법

불변 객체(immutable object)는 최근의 React, Vue,js, Angular 등의 라이브러리나 프레임워크에서뿐만 아니라 함수형 프로그래밍, 디자인 패턴 등에서도 매우 중요한 기초가 되는 개념이다.

불변 객체가 필요한 경우 => 값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우

**_불변 객체를 만드는 방법_**

- 매번 새로운 객체를 만들어 재할당
- 새로운 객체를 만드는 도구 활용
  - 대표적으로 immutable.js, immer.js, immutability-helper 등의 라이브러리
  - ES6의 spread operator, Object.assign 메서드 등

```javascript
// 기존 정보를 복사해서 새로운 객체를 반환하는 함수(얕은 복사)
var copyObject = function (target) {
  var result = {};
  for (var prop in target) {
    result[prop] = target[prop];
  }
  return result;
};
```

위 방법을 사용하면 result 객체에 target 객체의 프로퍼티들을 복사할 수 있다.

> 하지만 아쉬운 점으로 프로토타입 체이닝 상의 모든 프로퍼티를 복사하는 점, getter/setter는 복사하지 않는 점, **얕은 복사** 만을 수행한다는 점이 있지만 이 문제를 모두 보안하려면 함수가 무거워질 수 밖에 없다.

### 얕은 복사와 깊은 복사

- 얕은 복사(shallow copy) : 바로 아래 단계의 값만 복사하는 방법
- 깊은 복사(deep copy) : 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법

위에서 본 함수는 바로 아래 단계의 값만 복사하므로 얕은 복사이다. 그래서 중첩된 객체를 위 함수로 사용하여 복사하면 원복과 사본 모두 동일한 참조형 데이터를 가리키게 된다.

```javascript
// 객체의 깊은 복사를 수행하는 범용 함수
var copyObjectDeep = function (target) {
  var result = {};
  if (typeof target === "object" && target !== null) {
    // target !== null
    // typeof 명령어가 null에 대해서도 'object'를 반환하기 때문이다.
    // (자바스크립트 자체의 버그)
    for (var prop in target) {
      result[prop] = copyObjectDeep(target[prop]);
    }
  } else {
    result = target;
  }

  return result;
};
```

JSON을 활용하면 간단한 깊은 복사가 가능하다.

```javascript
var copyObjectViaJson = function (target) {
  return JSON.parse(JSON.stringify(target));
};
```

## undefined와 null

자바스크립트에는 '없음'을 나타내는 값이 두 가지 있다.

**undefined가 반환되는 경우**

- 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
- 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
- return 문이 없거나 호출되지 않는 함수의 실행 결과

값을 대입하지 않은 경우에 대해 배열의 경우에는 조금 특이한 동적을 한다.

```javascript
var arr1 = [];
arr1.length = 3;
console.log(arr1); // [empty x 3];

var arr2 = new Array(3);
console.log(arr2); // [empty x 3];

var arr3 = [undefined, undefined, undefined];
console.log(arr3); // [undefined, undefined, undefined]
```

'비어있는 요소'와 'undefined를 할당한 요소'는 출력 결과부터 다르다. '비어있는 요소'는 순회와 관련된 많은 배열 메서드들의 순회 대상에서 제외된다.

```javascript
var arr1 = [undefined, 1];
var arr2 = [];
arr2[1] = 1;

arr1.forEach(function (v, i) {
  console.log(v, i);
}); // undefined 0 / 1 1
arr2.forEach(function (v, i) {
  console.log(v, i);
}); // 1 1

arr1.map(function (v, i) {
  return v + i;
}); // [NaN, 2]
arr2.map(function (v, i) {
  return v + i;
}); // [empty, 2]

arr1.filter(function (v) {
  return !v;
}); // [undefined]
arr2.filter(function (v) {
  return !v;
}); // []

arr1.reduce(function (p, c, i) {
  return p + c + i;
}); // undefined011
arr2.reduce(function (p, c, i) {
  return p + c + i;
}); // 11
```

'비어있음'을 명시적으로 나타내고 싶을 때는 undefined가 아닌 null을 쓰는 것을 권장한다.

> 주의할 점  
> **_자바스크립트 자체 버그_**  
> `type null === 'object'`
