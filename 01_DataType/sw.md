# 데이터 타입
## 데이터 타입의 종류
크게 원시타입 (primitive type)과 참조타입(reference type)으로 구분된다
참조타입은 객체 타입으로 봐도 무방하다
- 원시 타입: 숫자, 문자열, 불리언, null, undefined, Symbol
- 참조 타입: 객체, 배열, 함수, 날짜, 정규표현식, Set, Map 등


원시타입은 불변성을 띈다
참조타입은 불변성을 띄지 않는다

자바스크립트에서 값을 여러 변수에서 공유하게 되면
값을 가지고 있는 메모리 주소를 공유하게 된다
이 때 원시타입은 메모리 영역에 값 자체를 갖고 있지만
참조타입 (객체타입)은 객체의 주소만을 갖고 있다

떄문에 한 번 생성된 원시타입의 메모리 공간은 
값이 회수되어 초기화되기 전 까지 다른 값으로 변경되지 않는다 
이를 불변성을 띈다고 표현한다

객채의 경우 한 메모리 공간 안에서 내부의 값은 계속 변경될 수 있다


#### 변수와 식별자
변수는 메모리 공간을 뜻하고 
메모리 공간은 변경 가능한 데이터가 담길 수 있는 공간을 말한다
식별자는 변수명 등 데이터를 식별할 수 있게 하는 이름을 말한다

### 변수 선언
변수를 선언한다는 것은 메모리 공간을 사용하겠다고 선언하는 것이고
선언 시 `(변수 선언 키워드) a;` 형식으로 표기한다
이는 a 라는 이름을 갖는 변수를 선언하겠다는 뜻으로
앞으로 사용할 메모리 공간을 할당받겠다는 뜻이다
자바스크립트에서 var 키워드로 변수 선언 시 선언과 초기화가 함께 일어나고
초기화 값으로 undefined 를 갖게 된다

### 데이터 할당
변수에 값을 할당하는 방법은 두 가지가 있다
1. 선언된 변수에 데이터 할당
2. 선언과 동시에 데이터 할당

```js
var a;
a = 1

var a = 1
```
두 가지 모두 자바스크립트 엔진에서는 같은 동작을 수행하게 된다
선언문에 대해서 호이스팅이 일어나기 때문에 선언된 위치와 관계 없이
모두 코드 최상단에서 선언(var의 경우는 초기화 함꼐)이 실행되며
할당문은 런타임 시 인터프리터가 코드를 한 줄씩 해석하다가
할당문을 만나는 위치에서 실행된다

책에서는 변수 영역과 데이터 영역이란 이름으로 구분하였는데
변수 선언에서 할당받은 메모리 영역은 변수명이라는 이름으로
사용자가 참조할 수 있고 이는 변수명이 변수명에 대한 메모리 주소를 갖고 있다는 뜻이 된다
변수명이 참조하고 있는 메모리 영역의 값은 데이터 영역이라고 부르는
값이 존재하는 메모리 영역의 주소를 가지고 있다
해당 메모리 주소를 참조하면 사용자가 할당한 값이 들어있다

`var a = 1;` 의 경우 참조는 다음과 같다

a (변수명) -> 메모리 1003 (값: 메모리 5004 참조) -> 메모리 5004 -> 1 (할당한 숫자 값)

변수명을 갖는 변수 영역에 값을 직접 넣지 않고 한 단계 더 참조하는 것은
데이터 변환을 자유롭게 함과 동시에 메모리를 더욱 효율적으로 사용할 수 있게 한다
특이 문자열 등 메모리 용량이 가변적인 것에 대응하기 편리하다
이는 자바스크립트가 웹에서 사용되는 언어로 만들어졌기 때문에 특별히
고안된 것이 아닌가 하다

자바스크립트 내장 함수에 문자열 수정하는 함수가 있는데
이는 문자열을 수정하는 것이 아니라 수정된 결과에 대한 문자열을 새로 만들고 기존에 있던 것에 대한 참조를 끊는 방식이다
때문에 문자열 또한 불변성을 띈다
`var a = 'abc'` 의 경우
'abc' + 'def' 연산을 통해 'abcdef' 라는 문자열을 만든다면
변수 a가 기존에 참조하고 있던 'abc' 에 대한 참조를 버리고 
새 주소에 새롭게 생성된 값인 'abcdef'를 참조하게 된다

## 원시 타입과 참조 타입
### 원시타입 (불변값)
불변값은 변수와 상수의 개념과는 다르다
상수에서 변하지 않는 것은 변수 영역 메모리에 대한 것이고
불변값에서 변하지 않는 것은 데이터 영역 메모리에 대한 것이다

원시타입은 모두 불변성을 띈다고 했다

변수 a와 b가 모두 값으로 5를 할당 받았다고 하면
5라는 값은 특정 메모리 영역에 존재하고
a와 b가 해당 데이터 영역을 참조하게 된다
때문에 a === b 연산은 true 가 된다
자바스크립트는 변수의 주소를 직접 확인할 수 없기 떄문에
자바에서 확인해보면 위와 같은 결과를 볼 수 있다
확실히 이름만 따라한 것은 아닌 것 같다

### 참조타입 (가변값)
참조타입인 객체의 경우에는 기본적으로 가변값을 갖는다
설정에 따라 변경이 불가능하도록 만든 경우도 있고
불변값으로 만들 수 있는 방법도 있다

참조타입의 데이터 영역에는 객체를 참조하고 있는 메모리 주소를 값으로 갖게 된다
때문에 데이터 영역의 주소는 변경되지 않지만 객체가 가지고 있는 값이 변경될 수 있다
객체는 객체의 프로퍼티 영역이 별도로 존재하기 때문이다
객체는 매번 새로운 값을 새로 할당하는 것이 아니라 기존의 객체를 변경하면서 사용한다
객체가 갖는 프로퍼티의 값은 데이터 영역에 생성 후 참조된다 이미 데이터 영역에 존재하는 원시 값이라면 변수와 마찬가지로 기존에 생성된 값의 주소를 참조하여 사용한다
참조형 데이터의 프로퍼티 값에는 기존 데이터 영역에 생성되었던 값이 들어갈 수도 있고
다시 새로운 참조형 데이터를 값으로 가질 수도 있다
참조형 데이터가 다른 참조형 데이터를 값으로 가진 경우 중첩 객체라고 표현한다

### 가비지컬렉터
자바스크립트의가비지 컬렉터는 두 가지 방식으로 동작한다
참조 세기 알고리즘과 표시하고 쓸기 알고리즘
자신을 참조하는 변수의 개수를 참조 카운트라고 하고
이 참조 카운트가 0이 되었을 때 가비지 컬레터가 메모리를 회수해 간다
순환 참조의 경우 프로그램이 동작하는 내내 서로 참조하고 있는 변수들의 카운트가 1로 유지되어 메모리 누수가 일어날 수 있다
때문에 표시하고 쓸기 알고리즘이 필요하다
표시하고 쓸기 알고리즘은 참조 가능성을 보고 root 객체에서 참조할 수 없는 변수는 쓸모 없는 값으로 판단하여 메모리를 회수한다
하지만 정확한 시점은 알 수 없다

## 얕은 복사와 깊은 복사
자바스크립트에서 데이터의 비교와 복사는 데이터 영역을 비교, 복사 하는 것이다
때문에 원시타입의 경우 값을 대상으로 할 수 있지만
참조타입의 경우 객체의 주소를 비교, 복사하게 된다

객체를 다른 곳에서 복사해서 쓴다면 하나의 객체를 공유하게 되기 때문에
한 쪽에서 변경된 값이 다른 변수에도 적용되게 된다
이는 사용자 입장에서 큰 혼란을 겪게 될 수 있기 때문에
불변성을 강조하게 되는 것 같다

참조 타입의 경우 기본적으로 객체의 주소를 복사하게 되기 때문에
값 까지는 복사할 수 없다고 하여 얕은 복사라고 부르고
참조의 끝까지 찾아가 값을 복사해오는 것은 깊은 복사라고 부른다

깊은 복사를 위해선 재귀적 방법을 사용하거나 loadsh 같은 라이브러리를 사용할 수 있다
스프레드 문법이나 Object.assing() 메서드를 사용할 수도 있지만
두 가지 방법 모두 중첩 객체에 대해서는 깊은 복사를 할 수 없다

비교 시에는 JSON.stringify() 메소드로 문자열로 변환 후 비교하는 방법도 있지만 일정 깊이 이상으로 가면 원하는데로 동작하지 않을 수 있다

## 불변 객체 만들기
불변 객체는 매우 중요한 기초 개념이다
내부 프로퍼티 변경이 필요할 시 매번 새로운 객체를 만들거나
immutable.js 등의 라이브러리를 사용할 수 있다

## undefined와 null
자바스크립트에서 없음을 나타내는 값은 두 가지가 있다
undefined 는 값이 없음을 나타내는 값 (데이터 영역에 undefined가 있다)
null 은 변수가 참조할 데이터 영역의 주소가 없음을 나타낸다

undefined 는 변수(프로퍼티) 초기화에 사용되거나 return 문이 없는 함수의 반환 값으로 사용된다
null 은 값 자체가 없는 것

undefined 는 연산은 되지 않지만 에러를 발생시키지 않기 때문에
사용자는 값이 없음을 나타낼 때 null 을 사용하여 명확하게 문제를 해결하고 넘어가는 편이 좋을 것 같다
하지만 null 을 만든 개발자는 수십억짜리 실수라고 하면서 null 로 인해 터진 서비스들이 입은 손실에 대해 심심한 위로를 전했다

자바스크립트의 희소 배열에는 빈 공간에 empty 라는 것이 들어가기도 한다

typeof 로 null 을 검사하면 object 로 나오는데 이는 자바스크립트 초창기 버그다
하지만 이미 너무 많은 레거시가 있기 때문에 var 와 함께 아쉽지만 변경할 수는 없는 코드가 되었다

undefined == null // true 
이기 때문에
일치 연산자를 사용해야만 undefined 와 null을 구분할 수 있는데
동등 비교 연산자를 쓰는 사람이 있나..?

