## 클로저
클로저는 함수형 프로그래밍 언어의 보편적 특성이다
간단히 설명하면 자신 환경의 생명주기는 끝났으나 
자신을 어디선가 참조하고 있어
가비지 컬렉터가 회수해 가지 않는 함수로
메모리 회수가 일어나지 않아 참조가 끊어지기 전까지 계속 사용 가능한 것이다

이론상 자바스크립트의 모든 함수는 클로저이지만
자신의 스코프가 끝난 이후에 살아있는 함수만 클로저라고 부른다

자바스크립트의 가비지 참조 세기와 컬렉터는 표시하고 쓸기 알고리즘으로
메모리를 회수하는데
클로저의 경우 참조 세기의 숫자가 1 이상이면서 루트 객체에서 참조할 수 있기 때문에
회수 대상이 아니다

```javascript
const outer = () => {
  let a = 0;
  const inner = () => {
    console.log(a);
    a += 1
  }
  return inner;
};
const result = outer();
result() // 0
result() // 1
result() // 2
```

MDN 에서는 선언될 당시의 렉시컬 환경의 상호관계에 따른 현상 이라고 설명하고 있다
선언될 당시의 lexical enviroment 는 
실행 컨텍스트의 enviromentRecord 와 outerEnviromentReference 중
outerEnviromentReference 에 해당한다

위에서는 inner 함수를 반환했다
outer 의 실행 컨텍스트가 종료될 때 result 는 outer 의 결과인 inner 함수를 참조하게 된다
inner 함수의 실행 컨텍스트 내 enviromentRecord 에는 수집할 정보가 없고
outerEnviromentReference 에는 inner 함수가 선언된 위치의 LexicalEnviroment 가
참조 복사된다
inner 함수는 outer 함수 내부에서 선언되었으므로
outer 함수의 LexicalEnviroment 가 담긴다
스코프 체이닝을 통해 outer 에서 선언한 변수 a 에 접근하여 사용 가능하다

이 때 outer 함수를 클로저라고 한다

inner 는 변수에 담겨 실행 컨텍스트가 살아있고
outer 는 outer 의 변수를 inner 에서 참조하고 있기 때문에 실행 컨텍스트가 살아있게 된다

### 클로저와 메모리 관리
클로저는 매우 중요한 개념이다
메모리 누수 위험을 이유로 클로저를 조심해야 한다는 사람들도 있다
사용자 모르게 계속 참조되고 있는 함수가 있다면 메모리 누수를 직관적으로 알기 힘들기 때문에 그렇다
하지만 최근에는 자바스크립트 엔진이 발전하면서 그런 일이 거의 없다
이제는 메모리 누수 걱정 보다는 클로저의 동작 방식을 잘 파악해 활용할 수 있어야 한다

클로저의 메모리 관리는 간단하다
의도적으로 함수의 지역변수를 참조하지 않게 해주면 된다
다 쓴 클로저 식별자에 null 이나 undefined 를 할당하면 된다

### 클로저의 활용

#### 콜백 함수 내부에서 외부 데이터 사용

#### 정보 은닉

#### 부분 적용 함수
n 개의 인자를 받는 함수의 미리 m 개의 인자만 넘겨 기억시켰다가
이후에 n-m 개의 인자를 넘기면 실행 결과를 얻을 수 있도록 작성하는 경우

#### 커링 함수
여러개의 인자를 받는 함수를 하나의 인자만 받는 함수로 나누어
순차 호출되도록 구성한 것
함수형 프로그래밍에서 중요하다..
순수함수들을 조합해서 사용하기 때문




